deepdive {
  
  db.default: {
    driver: "org.postgresql.Driver"
    url: "jdbc:postgresql://localhost:5432/deepdive_kbp"
    user: "msushkov"
    password: ""
  }

  # The variables in our factor graph are (entity, mention) pairs
  schema.variables {
    link.is_correct: Boolean
  }

  extraction.extractors: {

    mention_features: {
      input: "SELECT * FROM mention"
      udf: "examples/kbp/udf/extract_mention_features.py"
      output_relation: "mention_features"
      parallelism: 4
    }
    
    entity_features: {
      input: "SELECT * FROM entity"
      output_relation: "entity_features"
      udf: "examples/kbp/udf/extract_entity_features.py"
      parallelism: 4
    }

    # Extract possible (entity, mention) pairs based on the feature: exact string match
    exact_match: {
      input: "SELECT * FROM mention_features INNER JOIN entity_features ON mention_features.text_lc = entity_features.text_lc"
      output_relation: "candidate_link_exact_match"
      udf: "examples/kbp/udf/extract_content_eq.py"
      parallelism: 4
      dependencies: ["entity_features", "mention_features"]
    }

    # Get all the unique (e, m) pairs
    distinct_links: {
      input: "SELECT DISTINCT (eid, mid) FROM candidate_link_exact_match"
      output_relation: link
      udf: "examples/kbp/udf/extract_unique_em.py"
      parallelism: 4
      dependencies: ["exact_match"]
    }
  }

  inference.factors: {

    # Unary factors for a given (e, m) variable, depending on the type of feature that was extracted for the pair (e.g. edit distance)
    exact_string_match: {
      input_query: "SELECT l.id as \"l.id\", c.feature_type AS \"c.feature_type\", l.is_correct AS \"l.is_correct\" FROM link AS l INNER JOIN candidate_link_exact_match AS c ON (l.eid = c.eid AND l.mid = c.mid)"
      function: "l.is_correct = Imply()"
      weight: "?(c.feature_type)"
    }

    # A given mention can only link to 1 entity (no (e, m) pair with the same mid value can have the same eid value).
    single_mention_to_one_entity: {
      input_query: "SELECT l1.id AS \"l1.id\", l1.is_correct AS \"l1.is_correct\", 1 AS const FROM link AS l1, link AS l2 WHERE l1.mid = l2.mid AND l1.eid <> l2.eid"
      function: "l1.is_correct = Imply()"
      weight: "?(const)" # the weight is the same for all instances of this rule
    }
  }

  calibration.holdout_fraction: 0.0

  sampler.sampler_args: "-l 100 -s 10 -i 100 -t 1"

}