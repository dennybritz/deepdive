deepdive {
  
  db.default: {
    driver: "org.postgresql.Driver"
    url: "jdbc:postgresql://localhost:5432/deepdive_kbp"
    user: "msushkov"
    password: ""
  }

  # The variables in our factor graph are (entity, mention) pairs
  schema.variables {
    link_feature.is_correct: Boolean
  }

  extraction.extractors: {

    # Extract possible (entity, mention) pairs based on several predicates:
    # exact string match (lowercase), Levenshtein distance < 3, similarity score >= 0.75.
    find_candidates: {
      input: """
        SELECT * FROM mention INNER JOIN entity ON
        (lower(mention.text_contents) = lower(entity.text_contents) OR
        levenshtein(lower(mention.text_contents), lower(entity.text_contents)) < 3 OR
        similarity(lower(mention.text_contents), lower(entity.text_contents)) >= 0.75)"""
      output_relation: "candidate_link"
      udf: "examples/kbp/udf/find_candidates.py"
      parallelism: 8

      # create a view that only contains the distinct (e, m) candidate pairs
      after: "examples/kbp/helper_scripts/distinct_candidates_view.sh"
    }

    # Extract features for (e, m) pairs that are candidates
    feature_extraction: {
      input: """
        SELECT * FROM distinct_candidates_view INNER JOIN mention 
        ON (distinct_candidates_view.mid = mention.id) INNER JOIN entity 
        ON (distinct_candidates_view.eid = entity.id)
      """
      output_relation: "link_feature"
      udf: "examples/kbp/udf/extract_features.py"
      parallelism: 8
      dependencies: ["find_candidates"]
    }
  }

  inference.factors: {

    # Unary factors for a given (e, m) variable, depending on the type of feature that was extracted for the pair (e.g. edit distance)
    exact_string_match: {
      input_query: "SELECT * FROM link_feature"
      function: "link_feature.is_correct = Imply()"
      weight: "?(link_feature.feature_type)"
    }

    # A given mention can only link to 1 entity (no (e, m) pair with the same mid value can have
    # the same eid value).
    single_mention_to_one_entity: {
      input_query: """
        SELECT l1.id AS "l1.id", l1.is_correct AS "l1.is_correct"
        FROM link_feature AS l1, link_feature AS l2 
        WHERE l1.mid = l2.mid AND l1.eid <> l2.eid"""
      function: "l1.is_correct = Imply()"
      weight: "?" # the weight is the same for all instances of this rule
    }
  }

  calibration.holdout_fraction: 0.0

  sampler.sampler_args: "-l 100 -s 10 -i 100 -t 1"

}