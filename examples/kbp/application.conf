deepdive {
  
  db.default: {
    driver: "org.postgresql.Driver"
    url: "jdbc:postgresql://localhost:5432/deepdive_kbp"
    user: "msushkov"
    password: ""
  }

  # The variables in our factor graph are (entity, mention) pairs
  schema.variables {
    candidate_link.is_correct: Boolean
  }

  extraction.extractors: {

    # Extract possible (entity, mention) pairs based on several predicates:
    # exact string match (lowercase); Levenshtein distance < 3; similarity score >= 0.75;
    # if one of the strings is a subset of the other
    find_candidates: {
      input: """
        SELECT * FROM mention INNER JOIN entity ON
          (lower(mention.text_contents) = lower(entity.text_contents) OR
          levenshtein(lower(mention.text_contents), lower(entity.text_contents)) < 3 OR
          similarity(lower(mention.text_contents), lower(entity.text_contents)) >= 0.75) OR
          position(lower(mention.text_contents), lower(entity.text_contents)) >= 0 OR
          position(lower(entity.text_contents), lower(mention.text_contents)))"""
      output_relation: "candidate_link"
      udf: "examples/kbp/udf/find_candidates.py"
      parallelism: 4
    }

    # load the positive and negative training examples
    load_examples: {
      input: "SELECT * FROM candidate_link"
      output_relation: "candidate_link"
      udf: "examples/kbp/udf/load_examples.py"
      parallelism: 4
      dependencies: ["find_candidates"]
    }

    # Extract features for (e, m) pairs that are candidates
    feature_extraction: {
      input: """
        SELECT * FROM candidate_link INNER JOIN mention 
        ON (candidate_link.mid = mention.id) INNER JOIN entity 
        ON (candidate_link.eid = entity.id)"""
      output_relation: "link_feature"
      udf: "examples/kbp/udf/extract_features.py"
      parallelism: 4
      dependencies: ["load_examples"]
    }
  }

  inference.factors: {

    # Unary factors for a given (e, m) variable, depending on the type of feature that was extracted for the pair (e.g. edit distance)
    exact_string_match: {
      input_query: """SELECT * FROM link_feature AS f INNER JOIN candidate_link AS c ON
        (f.eid = c.eid AND f.mid = c.mid)"""
      function: "c.is_correct = Imply()"
      weight: "?(f.feature_type)"
    }

    # A given mention can only link to 1 entity (no (e, m) pair with the same mid value can have
    # the same eid value).
    single_mention_to_one_entity: {
      input_query: """SELECT * FROM 
          (SELECT * FROM link_feature AS l1, link_feature AS l2 
          WHERE l1.mid = l2.mid AND l1.eid <> l2.eid) AS t 
          INNER JOIN candidate_link AS c ON (t.l1.eid = c.eid AND t.l1.mid = c.mid)"""
      function: "c.is_correct = Imply()"
      weight: "?" # the weight is the same for all instances of this rule
    }
  }

  calibration.holdout_fraction: 0.25

  sampler.sampler_args: "-l 100 -s 10 -i 100 -t 1"

}