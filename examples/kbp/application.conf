deepdive {
  
  db.default: {
    driver: "org.postgresql.Driver"
    url: "jdbc:postgresql://localhost:5432/deepdive_kbp"
    user: "msushkov"
    password: ""
  }

  # The variables in our factor graph are (entity, mention) pairs
  schema.variables {
    candidate_link.is_correct: Boolean
  }

  extraction.extractors: {

    # Extract possible (entity, mention) pairs based on several predicates:
    # exact string match (lowercase); Levenshtein distance < 3;
    # if one of the strings is a subset of the other
    find_candidates: {
      input: """
        SELECT * FROM mention INNER JOIN entity ON (
          lower(mention.text_contents) = lower(entity.text_contents))
          #levenshtein(lower(mention.text_contents), lower(entity.text_contents)) < 2 OR
          #position(lower(mention.text_contents) in lower(entity.text_contents)) >= 0 OR
          #position(lower(entity.text_contents) in lower(mention.text_contents)) >= 0)"""
      output_relation: "candidate_link"
      udf: "examples/kbp/udf/find_candidates.py"
      parallelism: 4
    }

    # load the positive and negative training examples
    load_examples: {
      input: """SELECT c.id AS "link_id", c.mid AS "mid", c.eid AS "eid",
        m.text_contents AS "text_contents" FROM candidate_link AS c INNER JOIN mention AS m
        ON (c.mid = m.mid)"""
      output_relation: "evidence"
      udf: "examples/kbp/udf/load_examples.py"
      parallelism: 4
      dependencies: ["find_candidates"]
      after: "insert_examples_into_candidate_table.sh"
    }

    # Extract features for (e, m) pairs that are candidates
    feature_extraction: {
      input: """
        SELECT * FROM candidate_link INNER JOIN mention 
        ON (candidate_link.mid = mention.id) INNER JOIN entity 
        ON (candidate_link.eid = entity.id)"""
      output_relation: "link_feature"
      udf: "examples/kbp/udf/extract_features.py"
      parallelism: 4
      dependencies: ["load_examples"]
    }
  }

  inference.factors: {

    # Unary factors for a given (e, m) variable, depending on the type of feature that was
    # extracted for the pair (e.g. edit distance)
    feature: {
      input_query: """SELECT * FROM link_feature AS f INNER JOIN candidate_link AS c ON
        (f.link_id = c.id)"""
      function: "c.is_correct = Imply()"
      weight: "?(f.feature)"
    }

    # A given mention can only link to 1 entity (no (e, m) pair with the same mid value can have
    # the same eid value).
    single_mention_to_one_entity: {
      input_query: """SELECT * FROM 
          (SELECT * FROM candidate_link AS l1, candidate_link AS l2 
          WHERE l1.mid = l2.mid AND l1.eid <> l2.eid) AS t 
          INNER JOIN candidate_link AS c ON (t.l1.eid = c.eid AND t.l1.mid = c.mid)"""
      function: "c.is_correct = Imply()"
      weight: 10
    }
  }

  calibration.holdout_fraction: 0.25

  sampler.sampler_args: "-l 100 -s 10 -i 100 -t 1"

}