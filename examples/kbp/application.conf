deepdive {
  
  db.default: {
    driver: "org.postgresql.Driver"
    url: "jdbc:postgresql://localhost:5432/deepdive_kbp"
    user: "msushkov"
    password: ""
  }

  # The variables in our factor graph are (entity, mention) pairs
  schema.variables {
    candidate_link.is_correct: Boolean
  }

  extraction.extractors: {

    # Find mentions in raw text documents
    get_mentions: {
      input: "SELECT * FROM document"
      output_relation: "mention"
      udf: "examples/kbp/udf/get_mentions.py"
      parallelism: 8
    }

    # OR levenshtein(lower(m.text_contents), lower(e.text_contents)) < 3 OR position(lower(m.text_contents) in lower(e.text_contents)) >= 0 OR position(lower(e.text_contents) in lower(m.text_contents)) >= 0)


    # Extract possible (entity, mention) pairs based on several predicates:
    # exact string match (lowercase); Levenshtein distance < 3;
    # if one of the strings is a subset of the other
    find_candidates: {
      input: """
        SELECT * FROM mention AS m INNER JOIN entity AS e ON
        (lower(m.text_contents) = lower(e.text_contents))
      """
      output_relation: "candidate_link"
      udf: "examples/kbp/udf/find_candidates.py"
      parallelism: 8
      dependencies: ["get_mentions"]
    }

    # Load the positive training examples
    load_positive_examples: {
      input: """
        SELECT c.id AS "link_id" FROM positive_example AS p INNER JOIN mention AS m ON (p.text_contents = m.text_contents AND p.doc_id = m.doc_id)
        INNER JOIN candidate_link AS c ON m.id = c.mid AND p.eid = c.eid
      """
      output_relation: "evidence"
      udf: "examples/kbp/udf/load_positive_examples.py"
      parallelism: 4
      dependencies: ["find_candidates"]
      after: "insert_examples_into_candidate_table.sh"
    }

    # Generate the negative examples
    generate_negative_examples: {
      input: """
        SELECT c.id AS "link_id" FROM negative_example AS n INNER JOIN mention AS m ON (n.text_contents = m.text_contents AND n.doc_id = m.doc_id)
        INNER JOIN candidate_link AS c ON m.id = c.mid AND n.eid = c.eid
      """
      output_relation: "evidence"
      udf: "examples/kbp/udf/generate_negative_examples.py"
      parallelism: 4
      dependencies: ["find_candidates"]
    }

    # Extract features for (e, m) candidate pairs
    feature_extraction: {
      before: "insert_examples_into_candidate_table.sh"
      input: """
        SELECT * FROM candidate_link INNER JOIN mention 
        ON (candidate_link.mid = mention.id) INNER JOIN entity 
        ON (candidate_link.eid = entity.id)
      """
      output_relation: "link_feature"
      udf: "examples/kbp/udf/extract_features.py"
      parallelism: 4
      dependencies: ["load_positive_examples", "generate_negative_examples"]
    }

  }

  inference.factors: {

    # Unary factors for a given (e, m) variable, depending on the type of feature that was
    # extracted for the pair (e.g. edit distance)
    feature: {
      input_query: """SELECT * FROM link_feature AS f INNER JOIN candidate_link AS c ON
        (f.link_id = c.id)"""
      function: "Imply(c.is_correct)" # new syntax: change
      weight: "?(f.feature)"
    }

    # A given mention can only link to 1 entity (no (e, m) pair with the same mid value can have
    # the same eid value).
    single_mention_to_one_entity: {
      input_query: """SELECT * FROM 
          (SELECT * FROM candidate_link AS l1, candidate_link AS l2 
          WHERE l1.mid = l2.mid AND l1.eid <> l2.eid) AS t 
          INNER JOIN candidate_link AS c ON (t.l1.eid = c.eid AND t.l1.mid = c.mid)"""
      function: "Imply(c.is_correct)"
      weight: 10
    }
  }

  calibration.holdout_fraction: 0.25

  sampler.sampler_args: "-l 100 -s 10 -i 100 -t 1"

}